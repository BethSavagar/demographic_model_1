---
title: "OC_validation"
author: "Beth Savagar"
date: "2023-11-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r setup}

applied_example <- F
local <- T

############
## SETUP ##
############

# local filepath: 
if(local){
  filepath <- ""
}else{
  # cluster filepath
  filepath <- "/storage/users/bsavagar/"
}

## Libraries
source(paste0(filepath,"scripts/setup.R")) 

## Functions:
source(paste0(filepath, "functions/Appliedfunc.R")) # wrapper function
source(paste0(filepath, "functions/demos_summary.R")) # summary stats for output
source(paste0(filepath, "functions/dynmod-vac.R")) # flock dynamics model function
source(paste0(filepath, "functions/output.R")) # what to include in output df
source(paste0(filepath, "functions/GSA_outputs.R")) # summary stats accounting for vac
```


```{r loadpars}
## Load parameters
datafile1 <- "-OC_validation"
# load data for Applied-Examples & Applied-LHS
fix_age_data_full <- read_csv(paste0("data/Applied_parameters/state_vars","-OC_validation",".csv"),col_names=T)
var_demo_dataMort <- read_csv(paste0("data/Applied_parameters/demographics","-OC_validationMORT",".csv"), col_names=T)
var_demo_dataOff <- read_csv(paste0("data/Applied_parameters/demographics","-OC_validationOFF",".csv"), col_names=T)
imm_decay_corrected <- read_csv("data/imm_decay_bodjo_v2.csv") 
var_demo_data_backup <- read_csv(paste0("data/Applied_parameters/demographics","-OC_validation",".csv"), col_names=T)
OC_target <- read_csv("data/Applied_parameters/target-OC_validation.csv", col_names = T)
## Datasets
datasets <- fix_age_data_full %>% select(-c(parameter)) %>% colnames()
```

## Global Model Setup: 

```{r modsetup}
######################
## MODEL SETUP ##
######################

## Simulation:
TimeStop_dynamics <- 2*52 # 2 years only interested in rates for 1 y
TimeStop_transmission <- 24 # 1 day, hourly timestep for transmission component
min_pop <- 1 # set minimum size of population, if pop drops below then set to 0

#######################
## Vaccination Setup ##
#######################
# see applied_vaccination
pV <- 1
source("scripts/applied/applied_vaccination.R")
Vstart <- Vprog %>% filter(Vround==1) %>% pull(Vweek)

##################
## MODEL INPUTS ##
##################

turnover <- F; 
dynamics <- T; 
transmission <- F; 
clean_environment <- T

# timepoints for population growth
t2 <- TimeStop_dynamics/2 # 5 year pop growth
t1 <- TimeStop_dynamics


lhs <- T
lhs_n <- 1e4 # number of sets (parameter combinations)
lhs_n <- 100
pairs_plot <- F
SA <- TRUE

```

## VALID OFF LOOP: 

```{r validloop}

var_demo_data_full <- var_demo_dataOff

lhs_n <- 1000
## Model Output
output <- "off_only" # Output options: "summary" (stats with age-group prop), "summary_all" (stats with age-sex group prop), "dynamics" (pop metrics over time)
# create empty dataframe to store output
summary_df <- output_func(TimeStop_dynamics, output) 

# validOut = list to store outputs
GSAoutput <- c(); 
outOffls <- list()
offValidParsls <- list()

#####################
## PARALLELISATION ##
#####################

print("start-parallel")

## Local parallelisation
if(local){
  cores=detectCores()
  cl <- makeCluster(cores[1]-1)
  registerDoParallel(cl)
}else{
  cores=detectCores()
  cl <- makeCluster(10)
  registerDoParallel(cl)
}
print("parallel-verified")
print("start-model")


#####################
## LOOP ##
#####################

for(d in 1:length(datasets)){
  dataset <- datasets[d]
  
  ##################################
  ## LHS DEMOGRAPHIC PARS ##
  ##################################
  
  data_filename <- gsub("\\.", "", dataset)
  
  if (dataset == "lesnoff.ft") {
    rates <- "wkly"
  } else{
    rates <- "yrly"
  }
  
  # set seed
  set.seed(1) # so that results are consistent
  
  pars_min <- paste0(dataset, ".min") # minimum val
  pars_max <-  paste0(dataset, ".max") # maximum val
  fixdata <- dataset # set dataset for state_vars
  vardata <- dataset
  
  source("scripts/applied/applied_lhs.R") # output var_input_df contains all parameter combinations for uncertain demographics.
  
  
  # Format demographic parameter sets:
  var_input_backup <- var_input_df %>% as.data.frame()
  
  ################
  ## SIMULATION ##
  ################
  OutOff <- foreach (i = 1:nrow(var_input_backup),
                          .packages = c("dplyr", "tibble"),
                          .combine = "rbind") %dopar% {
                            print(i)
                            
                            var_input_full <- unlist(var_input_backup[i, ])
                            
                            App_func(
                              imm_decay_corrected,
                              var_input_full,
                              fix_age_data_full,
                              f_list,# initial state of female population
                              m_list, # initial state of male population
                              TimeStop_dynamics,# 1 year, weekly timestep for demographic component
                              TimeStop_transmission, # 1 day, hourly timestep for transission component
                              output,# model output: tracker or summary stats
                              summary_df, #
                              clean_environment,
                              Vstart,
                              Vprog,
                              fixdata,
                              vardata
                            )
                          }
  
  OutOff <- as.data.frame(OutOff) %>%
    mutate(set = 1:nrow(.)) %>%
    select(set, offF06, offF612,offF12end, 
           offM06, offM612, offAll)
  
  rateMin <- paste0(dataset,".targ.min")
  rateMax <-  paste0(dataset,".targ.max")
  
  # female mortality <12m target
  targ_min <- OC_target %>% filter(parameter == "Off_all") %>% select(all_of(`rateMin`)) %>% pull()
  targ_max <- OC_target %>% filter(parameter == "Off_all") %>% select(all_of(`rateMax`)) %>% pull()
  
  offTarg <- OutOff %>% mutate(off_targ = ifelse(offAll>=targ_min & offAll<=targ_max, 1, 0))
  outOffls[[d]] <- offTarg
  
  offValidIDs <- offTarg %>% filter(off_targ==1) %>% pull(set)
  offValidPars <- var_input_backup[offValidIDs, ] %>%
    select(contains("offtake"))
  offValidParsls[[d]] <- offValidPars
}

```

## 







## VALID MORT LOOP

```{r validMortLoop}

var_demo_data_full <- var_demo_dataMort

lhs_n <- 100
## Model Output
output <- "mort_only" # Output options: "summary" (stats with age-group prop), "summary_all" (stats with age-sex group prop), "dynamics" (pop metrics over time)
# create empty dataframe to store output
summary_df <- output_func(TimeStop_dynamics, output) 

# validOut = list to store outputs
GSAoutput <- c(); 
outMortls <- list()
mortValidParsls <- list()

#####################
## PARALLELISATION ##
#####################

print("start-parallel")

## Local parallelisation
if(local){
  cores=detectCores()
  cl <- makeCluster(cores[1]-1)
  registerDoParallel(cl)
}else{
  cores=detectCores()
  cl <- makeCluster(10)
  registerDoParallel(cl)
}
print("parallel-verified")
print("start-model")


#####################
## LOOP ##
#####################

for(d in 1:length(datasets)){
  dataset <- datasets[d]
  
  ##################################
  ## LHS DEMOGRAPHIC PARS ##
  ##################################
  
  data_filename <- gsub("\\.", "", dataset)
  
  if (dataset == "lesnoff.ft") {
    rates <- "wkly"
  } else{
    rates <- "yrly"
  }
  
  # set seed
  set.seed(1) # so that results are consistent
  
  pars_min <- paste0(dataset, ".min") # minimum val
  pars_max <-  paste0(dataset, ".max") # maximum val
  fixdata <- dataset # set dataset for state_vars
  vardata <- dataset
  
  source("scripts/applied/applied_lhs.R") # output var_input_df contains all parameter combinations for uncertain demographics.
  
  
  # Format demographic parameter sets:
  var_input_backup <- var_input_df %>% as.data.frame()
  
  ################
  ## SIMULATION ##
  ################
  OutMort <- foreach (i = 1:nrow(var_input_backup),
                     .packages = c("dplyr", "tibble"),
                     .combine = "rbind") %dopar% {
                       print(i)
                       
                       var_input_full <- unlist(var_input_backup[i, ])
                       
                       App_func(
                         imm_decay_corrected,
                         var_input_full,
                         fix_age_data_full,
                         f_list,# initial state of female population
                         m_list, # initial state of male population
                         TimeStop_dynamics,# 1 year, weekly timestep for demographic component
                         TimeStop_transmission, # 1 day, hourly timestep for transission component
                         output,# model output: tracker or summary stats
                         summary_df, #
                         clean_environment,
                         Vstart,
                         Vprog,
                         fixdata,
                         vardata
                       )
                     }
  
  OutMort <- as.data.frame(OutMort) %>%
    mutate(set = 1:nrow(.)) %>%
    select(set, mortF06, mortF612,mortF12end, 
           mortM06, mortM612)
  
  rateMin <- paste0(dataset,".targ.min")
  rateMax <-  paste0(dataset,".targ.max")
  
  
  # female mortality <12m target
  F1targ_min <- OC_target %>% filter(parameter == "mort1") %>% select(all_of(`rateMin`)) %>% pull()
  F1targ_max <- OC_target %>% filter(parameter == "mort1") %>% select(all_of(`rateMax`)) %>% pull()
  
  F2targ_min <- OC_target %>% filter(parameter == "mort2f") %>% select(all_of(`rateMin`)) %>% pull()
  F2targ_max <- OC_target %>% filter(parameter == "mort2f") %>% select(all_of(`rateMax`)) %>% pull()
  
  F3targ_min <- OC_target %>% filter(parameter == "mort3f") %>% select(all_of(`rateMin`)) %>% pull()
  F3targ_max <- OC_target %>% filter(parameter == "mort3f") %>% select(all_of(`rateMax`)) %>% pull()
  
  # Male mort <12m target
  M1targ_min <- OC_target %>% filter(parameter == "mort1") %>% select(all_of(`rateMin`)) %>% pull()
  M1targ_max <- OC_target %>% filter(parameter == "mort1") %>% select(all_of(`rateMax`)) %>% pull()
  
  M2targ_min <- OC_target %>% filter(parameter == "mort2m") %>% select(all_of(`rateMin`)) %>% pull()
  M2targ_max <- OC_target %>% filter(parameter == "mort2m") %>% select(all_of(`rateMax`)) %>% pull()
  
  
  mortTarg <- OutMort %>% 
    mutate(mortF1_targ = ifelse(mortF06>=F1targ_min & mortF06<=F1targ_max, 1, 0),
           mortF2_targ = ifelse(mortF612>=F2targ_min & mortF612<=F2targ_max, 1, 0),
           mortF3_targ = ifelse(mortF12end>=F3targ_min & mortF12end<=F3targ_max, 1, 0),
           mortM1_targ = ifelse(mortM06>=M1targ_min & mortM06<=M1targ_max, 1, 0),
           mortM2_targ = ifelse(mortM612>=M2targ_min & mortM612<=M2targ_max, 1, 0)) %>%
    mutate(targSum = apply(.[7:11],1,sum))
  
  outMortls[[d]] <- mortTarg
  
  mortValidIDs <- mortTarg %>% filter(targSum==5) %>% pull(set)
  mortValidPars <- var_input_backup[mortValidIDs, ] %>% 
    select(contains("mortality"))
  mortValidParsls[[d]] <- mortValidPars
}

```


## Biological / Field relevance of Parameter sets

## Conditions on Mortality Parameter sets:
- For all mortality parameter sets they must also satisfy the condition that youth mortality is greater than adult mortality (`mortality_y`>>`mortality_a`)


## Conditions on Offtake Parameter sets:
- For all offtake parameter sets they must also satisfy the condition that Young male offtake (off_m2) is higher than female offtake (off_f)

```{r checkPars}

rep_each <- function(x, times) {
  if (length(times) == 1) {
    rep(x, each = times)
  } else if (length(times) == length(x)) {
    rep(x, times = times)
  } else {
    stop('`times` must be length 1 or the same length as `x`')
  }
}

# create dataframe of valid offtake parameters with datasource (profile) included
# use dataframe to filter results, checking against realistic biological/field observations
# offtake_M2 (young males) should be higher than all other offtake values.

names(offValidParsls) <- datasets
off_nvalid <- sapply(offValidParsls, nrow) %>% as.vector()
off_ndataset <- rep_each(datasets, times = off_nvalid)
offValidParsdf <- do.call(rbind, offValidParsls) %>%
  as.data.frame() %>%
  mutate(prof = off_ndataset)

offtakeValid <- offValidParsdf %>% filter(NET_offtake_m2>NET_offtake_f)

offValidParsdf_long <- offValidParsdf %>% 
  select(-c(NET_offtake_y, min_age_offtake)) %>%
  gather(key = "par", val = "off", -prof)

# boxplot before filtering conditions: 
ggplot(offValidParsdf_long, 
       aes(x = par, y = off))+
  geom_boxplot()+
    facet_wrap(~prof, ncol = 5)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1))


# create dataframe of valid mortality parameters with datasource (profile) included
# use dataframe to filter results, checking against realistic biological/field observations
# mortality_y (youth mortality) should be higher than mortality_a (adult mortality)

names(mortValidParsls) <- datasets
mort_nvalid <- sapply(mortValidParsls, nrow)
mort_ndataset <- rep_each(datasets, times = mort_nvalid)
mortValidParsdf <- do.call(rbind, mortValidParsls) %>%
  mutate(prof = mort_ndataset)

mortalityValid <- mortValidParsdf %>% filter(mortality_y>mortality_a)

mortValidParsdf_long <- mortValidParsdf %>%
  gather(key = "par", val = "mort", -prof)

# boxplot before filtering conditions: 
ggplot(mortValidParsdf_long, 
       aes(x = par, y = mort))+
  geom_boxplot()+
    facet_wrap(~prof, ncol = 5)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1))


```



# when valid parameter sts decide randomly combine valid off and valid mort then feed into the model and test against RSA parameter sets.

